<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ConcurrentOutputObject.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Assignment for class CS5010</a> &gt; <a href="index.source.html" class="el_package">edu.neu.ccs.cs5010.assignment7.concurrent</a> &gt; <span class="el_source">ConcurrentOutputObject.java</span></div><h1>ConcurrentOutputObject.java</h1><pre class="source lang-java linenums">package edu.neu.ccs.cs5010.assignment7.concurrent;

import edu.neu.ccs.cs5010.assignment7.sequential.exception.IllegalThresholdException;
import edu.neu.ccs.cs5010.assignment7.sequential.pojo.GetPercentile;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.Map;
import java.util.TreeMap;
import java.util.concurrent.ConcurrentNavigableMap;
import java.util.concurrent.ConcurrentSkipListMap;

/**
 * The type Concurrent output object.
 */
<span class="fc" id="L16">public class ConcurrentOutputObject {</span>

  /**
   * the index of latency count in the arrayList.
   */
<span class="fc" id="L21">  public static final Integer INDEX_OF_COUNT = 0;</span>

  /**
   * the index of mean latency in the arrayList.
   */
<span class="fc" id="L26">  public static final Integer INDEX_OF_MEAN = 1;</span>

<span class="fc" id="L28">  public static final Integer FIFTH_PERCENTILE = 5;</span>
<span class="fc" id="L29">  public static final Integer NINTYNINE_PERCENTILE = 9;</span>

  //Key: second
  //Value: List of latencies
<span class="fc" id="L33">  private ConcurrentNavigableMap&lt;Long, ArrayList&lt;Long&gt;&gt; throughputMap</span>
      = new ConcurrentSkipListMap&lt;&gt;();

<span class="fc" id="L36">  private ConcurrentNavigableMap&lt;Long, Integer&gt; latencyMap</span>
      = new ConcurrentSkipListMap&lt;&gt;();

  //Key: second
  //Value: List of #latencies and mean latency, only two values.
<span class="fc" id="L41">  private TreeMap&lt;Long, ArrayList&lt;Long&gt;&gt; result = new TreeMap&lt;Long, ArrayList&lt;Long&gt;&gt;();</span>

<span class="fc" id="L43">  private Map&lt;Long, ArrayList&lt;Long&gt;&gt; thresholdResult = new TreeMap&lt;&gt;();</span>

<span class="fc" id="L45">  private Long maxSec = Long.MIN_VALUE;</span>
<span class="fc" id="L46">  private Long minSec = Long.MAX_VALUE;</span>
  //mark the key of the start of peak phase, inclusive
  private Long peakStartKey;
  //mark the index of the end of peak phase, exclusive
  private Long peakEndKey;

<span class="fc" id="L52">  private Long thresholdThroughputSum = 0L;</span>
<span class="fc" id="L53">  private Long thresholdLatencySum = 0L;</span>
<span class="fc" id="L54">  private Long thresholdMeanThroughput = 0L;</span>
<span class="fc" id="L55">  private Long thresholdMeanLatency = 0L;</span>
<span class="fc" id="L56">  private Long thresholdPeakThroughput = Long.MIN_VALUE;</span>
  private Long fifthPctThroughput;
  private Long nintyniePctLatency;

<span class="fc" id="L60">  private Long totalNumLatency = 0L;</span>
<span class="fc" id="L61">  private Long totalSumLatency = 0L;</span>
<span class="fc" id="L62">  private Long meanLatency = 0L;</span>
<span class="fc" id="L63">  private int percentile = 99;</span>
  private Long percentileResult;

  /**
   * Gets throughput map.
   *
   * @return the throughput map
   */
  public ConcurrentNavigableMap&lt;Long, ArrayList&lt;Long&gt;&gt; getThroughputMap() {
<span class="fc" id="L72">    return throughputMap;</span>
  }

  /**
   * Gets latency map.
   *
   * @return the latency map
   */
  public ConcurrentNavigableMap&lt;Long, Integer&gt; getLatencyMap() {
<span class="fc" id="L81">    return latencyMap;</span>
  }

  /**
   * Gets result.
   *
   * @return the result
   */
  public TreeMap&lt;Long, ArrayList&lt;Long&gt;&gt; getResult() {
<span class="fc" id="L90">    return result;</span>
  }

  /**
   * Given the threshold, find the peak phase from the bulk result generated by the map builder.
   *
   * @param threshold the threshold
   * @return the peak phase data represented in a Map data structure.
   * @throws Exception IllegalThresholdException
   */
  public Map&lt;Long, ArrayList&lt;Long&gt;&gt; findPeakPhase(Long threshold) throws Exception {
<span class="fc" id="L101">    Iterator&lt;Map.Entry&lt;Long, ArrayList&lt;Long&gt;&gt;&gt; setIt = result.entrySet().iterator();</span>
<span class="fc bfc" id="L102" title="All 2 branches covered.">    while (setIt.hasNext()) {</span>
<span class="fc" id="L103">      Map.Entry&lt;Long, ArrayList&lt;Long&gt;&gt; pair = setIt.next();</span>
<span class="fc" id="L104">      ArrayList&lt;Long&gt; currValue = pair.getValue();</span>
<span class="fc bfc" id="L105" title="All 2 branches covered.">      if (currValue.get(INDEX_OF_COUNT) &gt;= threshold) {</span>
<span class="fc" id="L106">        peakStartKey = pair.getKey();</span>
<span class="fc" id="L107">        break;</span>
      }
<span class="fc" id="L109">    }</span>
<span class="fc bfc" id="L110" title="All 2 branches covered.">    if (peakStartKey == null) {</span>
<span class="fc" id="L111">      System.out.println(&quot;peakStartKey is null.&quot;);</span>
<span class="fc" id="L112">      throw new IllegalThresholdException(&quot;Provided threshold is too high.&quot;);</span>
    }

<span class="fc" id="L115">    Iterator&lt;Map.Entry&lt;Long, ArrayList&lt;Long&gt;&gt;&gt; setIt2 = result.descendingMap().entrySet()</span>
<span class="fc" id="L116">        .iterator();</span>
<span class="pc bpc" id="L117" title="1 of 2 branches missed.">    while (setIt2.hasNext()) {</span>
<span class="fc" id="L118">      Map.Entry&lt;Long, ArrayList&lt;Long&gt;&gt; pair = setIt2.next();</span>
<span class="fc" id="L119">      ArrayList&lt;Long&gt; currValue = pair.getValue();</span>
<span class="fc bfc" id="L120" title="All 2 branches covered.">      if (currValue.get(INDEX_OF_COUNT) &gt;= threshold) {</span>
<span class="fc" id="L121">        peakEndKey = result.lowerKey(pair.getKey());</span>
<span class="fc" id="L122">        break;</span>
      }
<span class="fc" id="L124">    }</span>
<span class="fc" id="L125">    Map&lt;Long, ArrayList&lt;Long&gt;&gt; subResult = result.subMap(peakStartKey, peakEndKey);</span>
<span class="fc" id="L126">    this.thresholdResult = subResult;</span>
<span class="fc" id="L127">    return thresholdResult;</span>
  }


  /**
   * Add.
   *
   * @param partition the partition
   */
  public void addThroughputPartition(ConcurrentNavigableMap partition) {
<span class="fc" id="L137">    Iterator&lt;Long&gt; iter = partition.keySet().iterator();</span>
<span class="fc bfc" id="L138" title="All 2 branches covered.">    while (iter.hasNext()) {</span>
<span class="fc" id="L139">      Long key = iter.next();</span>
<span class="fc" id="L140">      ArrayList&lt;Long&gt; value = (ArrayList&lt;Long&gt;) partition.get(key);</span>
<span class="fc bfc" id="L141" title="All 2 branches covered.">      if (this.throughputMap.containsKey(key)) {</span>
<span class="fc" id="L142">        this.throughputMap.get(key).addAll(value);</span>
      } else {
<span class="fc" id="L144">        this.throughputMap.put(key, value);</span>
      }
<span class="fc" id="L146">    }</span>
<span class="fc" id="L147">  }</span>

  /**
   * Add.
   *
   * @param partition the partition
   */
  public void addLatencyPartition(ConcurrentNavigableMap partition) {
<span class="fc" id="L155">    Iterator&lt;Long&gt; iter = partition.keySet().iterator();</span>
<span class="fc bfc" id="L156" title="All 2 branches covered.">    while (iter.hasNext()) {</span>
<span class="fc" id="L157">      Long key = iter.next();</span>
<span class="fc" id="L158">      Integer value = (Integer) partition.get(key);</span>
<span class="fc bfc" id="L159" title="All 2 branches covered.">      if (this.latencyMap.containsKey(key)) {</span>
<span class="fc" id="L160">        Integer newValue = this.latencyMap.get(key) + value;</span>
<span class="fc" id="L161">        this.latencyMap.put(key, newValue);</span>
<span class="fc" id="L162">      } else {</span>
<span class="fc" id="L163">        this.latencyMap.put(key, value);</span>
      }
<span class="fc" id="L165">    }</span>
<span class="fc" id="L166">  }</span>

  /**
   * Process threshold result. As byproduct calculates 5 percentile throughput result calculates 99
   * percentile latency result
   *
   * @param thresholdResult the threshold result
   */
  public void analyzePeakPhase(Map&lt;Long, ArrayList&lt;Long&gt;&gt; thresholdResult) {
<span class="fc" id="L175">    TreeMap&lt;Long, ArrayList&lt;Long&gt;&gt; copyMap = new TreeMap&lt;&gt;(thresholdResult);</span>
<span class="fc" id="L176">    GetPercentile getThroughputPct = new GetPercentile((long) copyMap.size(), FIFTH_PERCENTILE);</span>
<span class="fc" id="L177">    GetPercentile getLatencyPct = new GetPercentile((long) copyMap.size(), NINTYNINE_PERCENTILE);</span>
<span class="fc" id="L178">    Iterator&lt;Map.Entry&lt;Long, ArrayList&lt;Long&gt;&gt;&gt; setIt = copyMap.entrySet().iterator();</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">    while (setIt.hasNext()) {</span>
<span class="fc" id="L180">      Map.Entry&lt;Long, ArrayList&lt;Long&gt;&gt; pair = setIt.next();</span>
<span class="fc" id="L181">      ArrayList&lt;Long&gt; value = pair.getValue();</span>
<span class="fc" id="L182">      Long currThroughput = value.get(INDEX_OF_COUNT);</span>
<span class="fc" id="L183">      Long currLatency = value.get(INDEX_OF_MEAN);</span>
<span class="fc" id="L184">      thresholdThroughputSum += currThroughput;</span>
<span class="fc" id="L185">      thresholdLatencySum += currLatency;</span>
<span class="fc" id="L186">      thresholdPeakThroughput = Math.max(thresholdPeakThroughput, currThroughput);</span>
<span class="fc" id="L187">      getThroughputPct.add(currThroughput);</span>
<span class="fc" id="L188">      getLatencyPct.add(currThroughput);</span>
<span class="fc" id="L189">    }</span>
<span class="fc" id="L190">    thresholdMeanThroughput = thresholdThroughputSum / this.thresholdResult.size();</span>
<span class="fc" id="L191">    thresholdMeanLatency = thresholdLatencySum / this.thresholdResult.size();</span>
<span class="fc" id="L192">    fifthPctThroughput = getThroughputPct.getPercentile();</span>
<span class="fc" id="L193">    nintyniePctLatency = getLatencyPct.getPercentile();</span>
<span class="fc" id="L194">  }</span>


  /**
   * Analyze all data and calculates requirement metrics.
   */
  public void analyzeAllData() {

    //this.throughputMap = this.throughputMap.descendingMap();
    //calculate percentile
<span class="fc" id="L204">    Long mapSize = Long.valueOf(throughputMap.size());</span>
    //construct the percentile calculation object based on the bucket results
<span class="fc" id="L206">    GetPercentile getPct = new GetPercentile(mapSize, percentile);</span>

<span class="fc" id="L208">    Iterator&lt;Map.Entry&lt;Long, ArrayList&lt;Long&gt;&gt;&gt; setIt = this.throughputMap.entrySet().iterator();</span>
<span class="fc bfc" id="L209" title="All 2 branches covered.">    while (setIt.hasNext()) {</span>
<span class="fc" id="L210">      Map.Entry&lt;Long, ArrayList&lt;Long&gt;&gt; pair = setIt.next();</span>
<span class="fc" id="L211">      Long key = pair.getKey();</span>
<span class="fc" id="L212">      ArrayList&lt;Long&gt; value = pair.getValue();</span>
<span class="fc" id="L213">      this.maxSec = Long.max(key, this.maxSec);</span>
<span class="fc" id="L214">      this.minSec = Long.min(key, this.minSec);</span>
<span class="fc" id="L215">      Long numLatency = Long.valueOf(value.size());</span>
<span class="fc" id="L216">      Long sumLatency = 0L;</span>
<span class="fc bfc" id="L217" title="All 2 branches covered.">      for (Long d : value) {</span>
<span class="fc" id="L218">        sumLatency += d;</span>
<span class="fc" id="L219">        getPct.add(d);</span>
<span class="fc" id="L220">      }</span>
<span class="fc" id="L221">      ArrayList&lt;Long&gt; newValue = new ArrayList&lt;Long&gt;();</span>
<span class="fc" id="L222">      newValue.add(numLatency);</span>
<span class="fc" id="L223">      newValue.add(sumLatency / numLatency);</span>
<span class="fc" id="L224">      this.totalNumLatency += numLatency;</span>
<span class="fc" id="L225">      this.totalSumLatency += sumLatency;</span>
<span class="fc" id="L226">      this.meanLatency = this.totalSumLatency / this.totalNumLatency;</span>
<span class="fc" id="L227">      this.result.put(key, newValue);</span>
<span class="fc" id="L228">    }</span>

<span class="fc" id="L230">    this.percentileResult = getPct.getPercentile();</span>
<span class="fc" id="L231">  }</span>

  /**
   * Gets threshold mean throughput.
   *
   * @return the threshold mean throughput
   */
  public Long getThresholdMeanThroughput() {

<span class="fc" id="L240">    return thresholdMeanThroughput;</span>
  }

  /**
   * Gets threshold mean latency.
   *
   * @return the threshold mean latency
   */
  public Long getThresholdMeanLatency() {
<span class="fc" id="L249">    return thresholdMeanLatency;</span>
  }

  /**
   * Gets threshold peak throughput.
   *
   * @return the threshold peak throughput
   */
  public Long getThresholdPeakThroughput() {
<span class="fc" id="L258">    return thresholdPeakThroughput;</span>
  }

  /**
   * Gets threshold 5th percentile throughput.
   *
   * @return the threshold 5th percentile throughput
   */
  public Long getFifthPctThroughput() {
<span class="fc" id="L267">    return fifthPctThroughput;</span>
  }

  /**
   * Gets threshold 99th percentile latency.
   *
   * @return threshold 99th percentil latency
   */
  public Long getNintyniePctLatency() {
<span class="fc" id="L276">    return nintyniePctLatency;</span>
  }

  /**
   * Gets the peak phase start key.
   *
   * @return Long value of the peakStartKey
   */
  public Long getPeakStartKey() {
<span class="fc" id="L285">    return peakStartKey;</span>
  }

  /**
   * Gets the peak phase end key.
   *
   * @return Long value of the peakEndKey
   */
  public Long getPeakEndKey() {
<span class="fc" id="L294">    return peakEndKey;</span>
  }

  /**
   * Gets test length.
   *
   * @return the test length
   */
  public Long getTestLength() {
<span class="fc" id="L303">    return this.maxSec - this.minSec;</span>
  }

  public Long getMaxSec() {
<span class="fc" id="L307">    return this.maxSec;</span>
  }

  public Long getMinSec() {
<span class="fc" id="L311">    return this.minSec;</span>
  }

  public Long getTotalNumLatency() {
<span class="fc" id="L315">    return this.totalNumLatency;</span>
  }

  public Long getTotalSumLatency() {
<span class="fc" id="L319">    return this.totalSumLatency;</span>
  }

  public Long getMeanLatency() {
<span class="fc" id="L323">    return this.meanLatency;</span>
  }

  /**
   * Gets percentile result.
   *
   * @return the percentile result
   */
  public Long getPercentileResult() {
<span class="fc" id="L332">    return percentileResult;</span>
  }

  public Long getTotalThroughput() {
<span class="fc" id="L336">    return this.getTotalNumLatency() / this.getTestLength();</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>